
# UrbanFootprint v1.5
# Copyright (C) 2016 Calthorpe Analytics
#
# This file is part of UrbanFootprint version 1.5
#
# UrbanFootprint is distributed under the terms of the GNU General
# Public License version 3, as published by the Free Software Foundation. This
# code is distributed WITHOUT ANY WARRANTY, without implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License v3 for more details; see <http://www.gnu.org/licenses/>.

from footprint.main.lib.functions import remove_keys, merge
from footprint.main.models.geospatial.feature import Feature
from footprint.main.utils.utils import full_module_path

__author__ = 'calthorpe_analytics'

class FeatureClassConfiguration(object):

    # For configuration only, only the abstract_class_name is retained
    # to prevent serializing classes
    abstract_class = None
    abstract_class_name = None
    class_name = None
    # Used to hold class-scope attributes. Some will be generated, but you can specify others explicitly and they will be merged together
    class_attrs = {}
    related_class_lookup=dict(
        config_entity='footprint.main.models.config.config_entity.ConfigEntity',
        layer='footprint.main.models.presentation.layer.layer.Layer'
    )
    # The scope id of the Geography table. Scenarios always scope to the Project geography table, for now
    geography_scope = None
    key = None
    fields = []
    related_fields = []
    # Indicates that the configuration was generated by introspecting a table, rather than by deliberate configuration
    generated = False
    # Indicates that the features should be created from the db_entity's LayerSelection features.
    # The LayerSelection is based on the user who last updated the db_entity (db_entity.updater)
    source_from_origin_layer_selection = False
    # Set to the origin Layer if source_from_origin_layer_selection is True
    # The LayerSelection to use is based on this user and the user whoe is the DbEntity.updater
    origin_layer_id = None
    # The default data_importer for features
    # The default imports based on the url of the db_entity--usually a special database url
    data_importer = None
    # This is only the owning DbEntity for feature_class_configuration of Result DbEntities
    feature_class_owner = None
    source_id_column = None
    # Import from the given db_entity key
    import_from_db_entity_key = None
    # The primary key of the source table when importing. Defaults to 'id'
    primary_key = None
    # The primary key type of the source table when importing. Defaults to 'integer'
    primary_key_type = None
    # Indicates that the Feature table represents a primary geography of the system
    # This means that other Feature tables will form geographic associations to the features
    # based on the type of intersection defined by DbEntity.feature_behavior.intersection property
    primary_geography = None
    # Optional specific fields to import from the import_from_db_entity_key feature table
    import_fields = None
    # Option to only import ids and not all fields. Good for tables that need all the rows of the import_from_db_entity_key table
    # but need the feature attributes to be blank
    import_ids_only = False
    #specifies whether dynamic classes should be created - used for tables that are not geographic features and are
    # used as analytic summary results etc.
    no_table_associations = False
    #Option to create an empty table with the schema of the django model
    empty_table = False
    #Optional django queryset to define a subselection for peer importer
    filter_query = None
    #Option to set table as the extent of a project
    use_for_bounds = None
    #option to allow the user to always drop this table and reimport it from source on footprint_init
    replace_table = False

    def __init__(self, **kwargs):
        """
            kwargs are the attributes of the class. None are required
        """
        abstract_class_name = full_module_path(kwargs['abstract_class']) if \
                                kwargs.get('abstract_class') else \
                                kwargs.get('abstract_class_name', full_module_path(Feature))
        updated_kwargs = merge(
            remove_keys(kwargs, ['abstract_class']),
            dict(abstract_class_name=abstract_class_name))
        self.__dict__.update(**updated_kwargs)


    @property
    def is_valid(self):
        """
        This is basically pointless
        :return:
        """
        return self.key and self.abstract_class_name
